from InputFinding import InputFinding
from InputData import InputData
from PlotData import PlotData
from TransformedSignalData import TransformedSignalData
from FilteredData import FilterData

import os
import filecmp
import unittest
import shutil
import numpy

class UnitTest(unittest.TestCase):

    def setupInputFinding(self):
        finding = InputFinding()
        path = 'standard_test_cases/input 1/Grade 0/experiment 1/test'
        finding.parameterSearch(path)
    def TestInputFinding(self):
        self.setupInputFinding()
        assert InputData.Get_Start_Freq() == 100, 'Starting Frequency is incorrect'
        assert InputData.Get_Stop_Freq() == 1000,'Stopping Frequency is incorrect'
        assert InputData.Get_Step_Freq() == 100,'Frequency Step is incorrect'
        assert len(InputData.Get_TDMS_Time()) == 10, 'TDMS Time does not have the proper number of entries'
        assert len(InputData.Get_TDMS_Data()) == 10, 'TDMS Data does not have the proper number of entries'

        #Somehow have to test the 2 major lists, unsure how at the moment. Testing length is not sufficient.
        #Additionally the Input Finding Module requests the user to input 3 values, this makes it hard to automate

    def setupInputData(self):
        InputData.Set_Start_Freq(100)
        InputData.Set_Stop_Freq(1000)
        InputData.Set_Step_Freq(100)
    def TestInputData(self):
        self.setupInputData()
        assert InputData.Get_Start_Freq() == 100, 'Starting Frequency is incorrect'
        assert InputData.Get_Stop_Freq() == 1000, 'Stopping Frequency is incorrect'
        assert InputData.Get_Step_Freq() == 100, 'Step Frequency is incorrect'
        #Again unsure how to test the other 2 functions containing lists
    
    def setupPlotData(self):
        plotter = PlotData()
        path = 'standard_test_cases/input 1/Analysis/Grade 0/Experiment 1/test'
        if not os.path.exists(path): os.makedirs(path+'/Event Pictures')
        else:
            shutil.rmtree(path) #remove whole analysis folder if it exists
            os.makedirs(path+'/Event Pictures')
            os.makedirs(path+'/Contour Plot')
        InputData.Set_Start_Freq(1)
        InputData.Set_Stop_Freq(2)
        InputData.Set_Step_Freq(1)
        InputData.Set_TDMS_Data(numpy.asarray([[1,2,3,4,5],[10,20,30,40,50]]))
        InputData.Set_TDMS_Time(numpy.asarray([[1,2,3,4,5],[100,200,300,400,500]]))
        TransformedSignalData.Set_Original_Transformed_Data(numpy.asarray([[2,4,6,8,10],[10,20,30,40,50]]))
        TransformedSignalData.Set_Original_Frequency_Data(numpy.asarray([[2,4,6,8,10],[10,20,30,40,50]]))
        plotter.plot(path)
    
    def TestPlotData(self):
        self.setupPlotData()
        assert filecmp.cmp('standard_test_cases/input 1/Expected Output/Analysis/Grade 0/experiment 1/test/Event Pictures/100kHz Original.png','standard_test_cases/input 1/Analysis/Grade 0/Experiment 1/test/Event Pictures/1kHz Original.png'), '100kHz is incorrect'
    '''    
    In order to give a set of plot tests I would need the "correct" plots to compare to. Can I create these with matplotlib manually?
    Other than having something to compare to this test should work fully.
    '''

    def TestTransformedSignalData(self):
        tests = [100,150.12,'Hello',[1,2,3],[[1,2,3],[4,5,6],[7,8,9]]]
        for test in tests:
            TransformedSignalData.Set_Original_Transformed_Data(test)
            TransformedSignalData.Set_Filtered_Transformed_Data(test)
            TransformedSignalData.Set_Original_Frequency_Data(test)
            TransformedSignalData.Set_Filtered_Frequency_Data(test)
            assert TransformedSignalData.Get_Original_Transformed_Data() == test, 'Original Transformed Data failed for test input: ' + str(test)
            assert TransformedSignalData.Get_Filtered_Transformed_Data() == test, 'Filtered Transformed Data failed for test input: ' + str(test)
            assert TransformedSignalData.Get_Original_Frequency_Data() == test, 'Original Frequency Data failed for test input: ' + str(test)
            assert TransformedSignalData.Get_Filtered_Frequency_Data() == test, 'Transformed Frequency Data failed for test input: ' + str(test)
            '''
            Is this test acceptable? Checks if what is stored by each "Set" method is returned by the corresponding "Get"
            In theory this is supposed to show whatever is set is properly returned by each pair.
            '''

    def TestFilteredData(self):
        tests = [100,150.12,'Hello',[1,2,3],[[1,2,3],[4,5,6],[7,8,9]]]
        for test in tests:
            FilterData.Set_Approximate_Coefficients(test)
            FilterData.Set_Detailed_Coefficients(test)
            assert FilterData.Get_Approximate_Coefficients() == test, 'Approximate Coefficients failed for test input: ' + str(test)
            assert FilterData.Get_Detailed_Coefficients() == test, 'Detailed Coefficients failed for test input: ' + str(test)
            
def suite():
        
    suite = unittest.TestSuite()
    suite.addTest(UnitTest("TestInputFinding"))
    suite.addTest(UnitTest("TestInputData"))
    #suite.addTest(UnitTest("TestPlotData"))
    suite.addTest(UnitTest("TestTransformedSignalData"))
    suite.addTest(UnitTest("TestFilteredData"))
    return suite

#The following lines are for swift execution of the test cases
runner = unittest.TextTestRunner()
tester = suite()
runner.run(tester)
modulesLeft = ['Filtering','Output','SignalTransform']
